<!DOCTYPE HTML>
<html lang="en">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Urknall Documentation - Binary</title>
<link href="../../css/stylesheet.css" media="screen" rel="stylesheet" type="text/css">
<link href="../../css/pygments.css" media="screen" rel="stylesheet" type="text/css">

<!-- Bootstrap -->
<link href="../../css/bootstrap.min.css" rel="stylesheet">

<!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
<!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
<!--[if lt IE 9]>
		<script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
		<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
	<![endif]-->

<!-- you don't need to keep this, but it's cool for stats! -->
<meta name="generator" content="nanoc 3.7.2">
</head>



<body>
<div class="navbar navbar-inverse navbar-fixed-top" role="navigation">
	<div class="container">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
				<span class="sr-only">Toggle navigation</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a class="navbar-brand" href="../../">Urknall Documentation</a>
		</div>
		<div class="collapse navbar-collapse">
			<ul class="nav navbar-nav">
				<li><a href="../quickstart/">QuickStart</a></li>
				<li><a href="../library/">Library</a></li>
				<li class="active"><a href="./">Binary</a></li>
			</ul>
		</div><!--/.nav-collapse -->
	</div>
</div>




<div class="container">

<h1 class="no_toc" id="urknall-binary">Urknall Binary</h1>

<p>While the urknall <a href="../library/">library</a> provides the handling of targets,
tasks and caching, the urknall binary helps managing projects that use the
library. This pattern is the result of an evolution that happened over the
course of almost a year. The steps of this evolution and the reasoning behind
them are described in the next subsections. Afterwards different use cases are
discussed.</p>

<ul id="markdown-toc">
  <li>
<a href="#urknalls-evolution">Urknall’s Evolution</a>    <ul>
      <li><a href="#fully-integrated-library">Fully Integrated Library</a></li>
      <li><a href="#integrated-with-a-binary">Integrated With A Binary</a></li>
      <li><a href="#a-binary-accessing-templates-on-github">A Binary Accessing Templates On Github</a></li>
    </ul>
  </li>
  <li>
<a href="#usage">Usage</a>    <ul>
      <li><a href="#project-scaffolding">Project Scaffolding</a></li>
      <li><a href="#template-management">Template Management</a></li>
    </ul>
  </li>
</ul>

<h2 id="urknalls-evolution">Urknall’s Evolution</h2>

<p>The concepts used matured over the course of about a year when different
approaches were tested and direction changed a few times, until development
settled with something pragmatic and usable. The basic concepts of how the
provisioning is executed have been pretty stable, while being renamed a lot.
Discussion mainly focussed on how to handle commands and templates.</p>

<h3 id="fully-integrated-library">Fully Integrated Library</h3>

<p>First the naive approach was used, with bundling everything with the library,
i.e. the implementations of some basic commands and templates were part of the
library itself. This meant users would use them like described in the
following:</p>

<pre><code class="language-golang highlight"><span class="k">import</span><span class="x"> </span><span class="p">(</span><span class="x">
  </span><span class="s">"github.com/dynport/urknall/commands"</span><span class="x">
  </span><span class="s">"github.com/dynport/urknall/packages"</span><span class="x">
</span><span class="p">)</span><span class="x">

</span><span class="k">type</span><span class="x"> </span><span class="n">template</span><span class="x"> </span><span class="p">{</span><span class="x">
  </span><span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">t</span><span class="x"> </span><span class="o">*</span><span class="n">template</span><span class="p">)</span><span class="x"> </span><span class="n">Render</span><span class="p">(</span><span class="n">pkg</span><span class="x"> </span><span class="n">urknall</span><span class="o">.</span><span class="n">Package</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
  </span><span class="n">pkg</span><span class="o">.</span><span class="n">AddTemplate</span><span class="p">(</span><span class="s">"ruby"</span><span class="p">,</span><span class="x"> </span><span class="o">&amp;</span><span class="n">packages</span><span class="o">.</span><span class="n">Ruby</span><span class="p">{</span><span class="n">Version</span><span class="o">:</span><span class="x"> </span><span class="s">"2.1.2"</span><span class="p">})</span><span class="x">
  </span><span class="n">pkg</span><span class="o">.</span><span class="n">AddCommands</span><span class="p">(</span><span class="s">"hello"</span><span class="p">,</span><span class="x"> </span><span class="o">&amp;</span><span class="n">commands</span><span class="o">.</span><span class="n">Shell</span><span class="p">(</span><span class="s">"echo hello world"</span><span class="p">))</span><span class="x">
</span><span class="p">}</span></code></pre>

<p>With this approach one major problems arises: Changes to templates or (even
worse) commands inside the library would break caches of users after updates.
As commands must not be idempotent this could have fatal consequences and is
not acceptable. As it is not easily possible to fix go library versions when
using them, this could result in different team members using different
versions of a template or command. This is like asking for disaster.</p>

<p>Another issue is that the provided templates are outside the scope of users,
i.e. they can change the templates directly, but have to move the according
code to their project manually. As urknall should not deliver the solutions to
all problems, but at most some initial help, another approach was required,
that allowed users to directly integrate those artefacts into their code base.</p>

<h3 id="integrated-with-a-binary">Integrated With A Binary</h3>

<p>In a second iteration an urknall binary was added that had the artefacts as
static assets shipped with it. Users would add these assets to their project as
needed. Even updating with later versions was easily possible, under the
assumption the project uses version control, which could be taken for granted
for anything serious. After an update of the urknall binary new versions of
templates could easily be added and changes could be verified against the
project’s version using the version control system.</p>

<p>The downside with this approach is that the binary gets bigger as the number of
assets increases and users must update the urknall binary (and library) to
update commands and templates to the latest version.</p>

<h3 id="a-binary-accessing-templates-on-github">A Binary Accessing Templates On Github</h3>

<p>In the last iteration the templates are fetched from github. While this
requires a network connection, it has the benefit, that changes to the
templates require no update of the urknall binary itself.</p>

<h2 id="usage">Usage</h2>

<p>Please note that the urknall binary queries the <a href="http://github.com" target="blank">Github
API</a>, that has a rate limit. If you
encouter this, try <a href="https://github.com/blog/1509-personal-api-tokens" target="blank">creating an API token</a>.
The token should reside in the environment as <code>GITHUB_TOKEN</code>.</p>

<p>TODO: modify the <code>init</code> and <code>templates add</code> commands to add files into a
subpackage of the user’s project so that godoc can work properly</p>

<h3 id="project-scaffolding">Project Scaffolding</h3>

<p>The urknall binary can be used to create a simple basic urknall provisioning
tool. This is to help with the basic steps of creating a new project. Besides a
basic file with a <code>main</code> function, that initializes and uses the urknall
system, some command definitions (with a fokus on ubuntu based systems) are
added.</p>

<pre><code class="language-shell highlight"><span class="gp">$ </span>urknall init example
created <span class="s2">"cmd_add_user.go"</span>
created <span class="s2">"cmd_as_user.go"</span>
created <span class="s2">"cmd_bool.go"</span>
created <span class="s2">"cmd_download.go"</span>
created <span class="s2">"cmd_extract_file.go"</span>
created <span class="s2">"cmd_file.go"</span>
created <span class="s2">"cmd_fileutils.go"</span>
created <span class="s2">"cmd_shell.go"</span>
created <span class="s2">"cmd_ubuntu.go"</span>
created <span class="s2">"cmd_wait.go"</span>
created <span class="s2">"main.go"</span></code></pre>

<p>The files installed contain the following commands:</p>

<ul>
  <li>
<code>InstallPackages</code> and <code>UpdatePackages</code> from <code>cmd_ubuntu.go</code>: These commands
are useful to manage packages on an ubuntu system. Replace these commands
with something that supports your platform if it is not ubuntu (or debian
based).</li>
  <li>
<code>Mkdir</code> from <code>cmd_fileutils.go</code>: Create directories with a owner and
permissions set accordingly.</li>
  <li>
<code>WriteFile</code> from <code>cmd_file.go</code>: The command will write given content to a
specific files with owner and permissions set as specified. The content will
be contained in the generated shell command  as gzipped and base64 encoded
string.</li>
  <li>
<code>Download</code> and <code>DownloadAndExtract</code> from <code>cmd_download.go</code>: Uses <code>curl</code> to
download content from a given URI and save or extract respectively it to a
given location.</li>
</ul>

<h3 id="template-management">Template Management</h3>

<p>We have some basic templates in stock we use a lot. Those can be added to a
project with the urknall binary.</p>

<ul>
  <li>
<code>urknall templates list</code> lists all available templates.</li>
  <li>
<code>urknall templates add &lt;template names&gt;</code> adds the given templates to the
project.</li>
</ul>

<p>The <code>urknall templates list</code> command lists the available templates. These are
retrieved from urknall’s
<a href="https://github.com/dynport/urknall/tree/master/examples" target="blank">github repository</a>,
so a network connection is required! At the time when this guide was written
the following templates were available:</p>

<pre><code class="language-shell highlight"><span class="gp">$ </span>urknall templates list
available templates:
<span class="k">*</span> docker
<span class="k">*</span> elasticsearch
<span class="k">*</span> firewall
<span class="k">*</span> golang
<span class="k">*</span> haproxy
<span class="k">*</span> jenkins
<span class="k">*</span> nginx
<span class="k">*</span> openvpn
<span class="k">*</span> postgis
<span class="k">*</span> postgres
<span class="k">*</span> rabbitmq
<span class="k">*</span> redis
<span class="k">*</span> ruby
<span class="k">*</span> syslogng
<span class="k">*</span> system</code></pre>


</div>


<hr/>

<footer>
<div class="container">
	<p>© <a href="http://www.dynport.de" target="_blank">Dynport GmbH</a> 2014</p>
</div>
</footer>


<!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="../../js/bootstrap.min.js"></script>
</body>
</html>
