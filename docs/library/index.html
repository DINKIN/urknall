<!DOCTYPE HTML>
<html lang="en">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Urknall Documentation - Library</title>
<link href="../../css/stylesheet.css" media="screen" rel="stylesheet" type="text/css">
<link href="../../css/pygments.css" media="screen" rel="stylesheet" type="text/css">

<!-- Bootstrap -->
<link href="../../css/bootstrap.min.css" rel="stylesheet">

<!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
<!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
<!--[if lt IE 9]>
		<script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
		<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
	<![endif]-->

<!-- you don't need to keep this, but it's cool for stats! -->
<meta name="generator" content="nanoc 3.7.2">
</head>



<body>
<div class="navbar navbar-inverse navbar-fixed-top" role="navigation">
	<div class="container">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
				<span class="sr-only">Toggle navigation</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a class="navbar-brand" href="../../">Urknall Documentation</a>
		</div>
		<div class="collapse navbar-collapse">
			<ul class="nav navbar-nav">
				<li><a href="../quickstart/">QuickStart</a></li>
				<li class="active"><a href="./">Library</a></li>
				<li><a href="../binary/">Binary</a></li>
			</ul>
		</div><!--/.nav-collapse -->
	</div>
</div>




<div class="container">

<h1 class="no_toc" id="urknall-library">Urknall Library</h1>

<p>The library part of urknall provides the core mechanisms to execute commands on
a target. For a detailed information on the API of urknall have look into the
<a href="http://godoc.org/github/dynport/urknall" target="blank">API documentation</a>. This guide
explains the basic ideas behind the concepts.</p>

<ul id="markdown-toc">
  <li><a href="#logging">Logging</a></li>
  <li>
<a href="#commands">Commands</a>    <ul>
      <li><a href="#the-commands-interface">The <code>Commands</code> Interface</a></li>
      <li><a href="#the-logger-interface">The <code>Logger</code> Interface</a></li>
      <li><a href="#the-renderer-interface">The <code>Renderer</code> Interface</a></li>
      <li><a href="#the-validator-interface">The <code>Validator</code> Interface</a></li>
    </ul>
  </li>
  <li>
<a href="#tasks">Tasks</a>    <ul>
      <li><a href="#manual-task-generation">Manual Task Generation</a></li>
      <li><a href="#caching">Caching</a></li>
    </ul>
  </li>
  <li><a href="#packages">Packages</a></li>
  <li>
<a href="#templates">Templates</a>    <ul>
      <li><a href="#anonymous-render-function">Anonymous Render Function</a></li>
      <li><a href="#annotations">Annotations</a></li>
    </ul>
  </li>
  <li>
<a href="#targets">Targets</a>    <ul>
      <li><a href="#remot-target">Remot Target</a></li>
      <li><a href="#local-target">Local Target</a></li>
      <li><a href="#sudo-without-password">Sudo Without Password</a></li>
    </ul>
  </li>
</ul>

<h2 id="logging">Logging</h2>

<p>Urknall’s logging must be configured prior to usage. Internally a
publisher-subscribe mechanism is used, that has more complex features, but the
default configuration should be sufficient in most cases. The <code>main.go</code> file
created by the <a href="../binary/#init">urknall binary</a> does so in the first line of
the run function:</p>

<pre><code class="language-golang highlight"><span class="k">func</span><span class="x"> </span><span class="n">run</span><span class="p">()</span><span class="x"> </span><span class="kt">error</span><span class="x"> </span><span class="p">{</span><span class="x">
  </span><span class="k">defer</span><span class="x"> </span><span class="n">urknall</span><span class="o">.</span><span class="n">OpenLogger</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">Stdout</span><span class="p">)</span><span class="o">.</span><span class="n">Close</span><span class="p">()</span><span class="x">
  </span><span class="c">// [...]</span><span class="x">
</span><span class="p">}</span></code></pre>

<p>This configures the logging to write all output to the process’s standard
output channel and close the logger on program termination (this is done using
the <code>defer</code> statement).</p>

<p>TODO: add more content on how to add a custom logger.</p>

<h2 id="commands">Commands</h2>

<p>What urknall actually does is executing commands on a target. Commands in the
sense of shell commands. Internally these are modelled using the <code>Commands</code>
interface. A basic set of implementations is provided using the <a href="../binary/#urknall_init">urknall
binary</a>. There is a most basic <code>ShellCommand</code> for
example, that is given a string, that is executed as is. A more advanced
example would be the <code>FileCommand</code> that writes given content to a file with
given owner and permissions.</p>

<p>The following subsubsections will show different interfaces that must (or can)
be implemented by commands and their intent.</p>

<h3 id="the-commands-interface">The <code>Commands</code> Interface</h3>

<p>Every command must implement the <code>Command</code> interface:</p>

<pre><code class="language-golang highlight"><span class="k">type</span><span class="x"> </span><span class="n">Command</span><span class="x"> </span><span class="k">interface</span><span class="x"> </span><span class="p">{</span><span class="x">
  </span><span class="n">Shell</span><span class="p">()</span><span class="x"> </span><span class="kt">string</span><span class="x">
</span><span class="p">}</span></code></pre>

<p>The <code>Shell</code> function must return the command that should be executed on the
remote host, i.e. the plain shell command. All standard <code>sh</code> features are
supported, from pipes to subshells and more.</p>

<p>TODO: add information on how to (or better not) use input and output redirects.</p>

<h3 id="the-logger-interface">The <code>Logger</code> Interface</h3>

<p>Some commands can get pretty complex and obfuscate the real intent by this
complexity. The <code>FileCommand</code> already mentioned is an example. To simplify the
logging output, there is the <code>Logger</code> interface.</p>

<pre><code class="language-golang highlight"><span class="k">type</span><span class="x"> </span><span class="n">Logger</span><span class="x"> </span><span class="k">interface</span><span class="x"> </span><span class="p">{</span><span class="x">
  </span><span class="n">Logging</span><span class="p">()</span><span class="x"> </span><span class="kt">string</span><span class="x">
</span><span class="p">}</span></code></pre>

<p>If a command implements this interface the function is called to generate the
string used for logging. Otherwise the raw output of the <code>Shell</code> function will
be used.</p>

<h3 id="the-renderer-interface">The <code>Renderer</code> Interface</h3>

<p>When writing templates it’s convenient to use it’s properties in the command
strings using go’s templating (templating in the sense of having special marks
in a string that are replaced with content) mechanism. The following example
show the benefit.</p>

<pre><code class="language-golang highlight"><span class="k">type</span><span class="x"> </span><span class="n">ExampleTemplate</span><span class="x"> </span><span class="k">struct</span><span class="x"> </span><span class="p">{</span><span class="x">
  </span><span class="n">Name</span><span class="x"> </span><span class="kt">string</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">et</span><span class="x"> </span><span class="o">*</span><span class="n">ExampleTemplate</span><span class="p">)</span><span class="x"> </span><span class="n">Render</span><span class="p">(</span><span class="n">pkg</span><span class="x"> </span><span class="n">urknall</span><span class="o">.</span><span class="n">Package</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
  </span><span class="n">pkg</span><span class="o">.</span><span class="n">AddCommands</span><span class="p">(</span><span class="s">"hello"</span><span class="p">,</span><span class="x"> </span><span class="n">Shell</span><span class="p">(</span><span class="s">"Hello {{ .Name }}"</span><span class="p">))</span><span class="x">
</span><span class="p">}</span></code></pre>

<p>This way no complex string concatenation is required, but values and functions
can be used directly. Error detection is deferred from compile to run time, but
as command building happens prior to starting the actual execution urknall will
fail early.</p>

<p>There are commands where the rendering must be limited to specific parts and it
is not sufficient to just render the output of the <code>Shell</code> function. This is a
problem for example with the the <code>FileCommand</code> example where the given content
must be rendered, as it encoded (base64) and zipped when returned.</p>

<p>For this to work commands must be rendered prior to usage. The <code>Renderer</code>
interface shows this is supported.</p>

<pre><code class="language-golang highlight"><span class="k">type</span><span class="x"> </span><span class="n">Renderer</span><span class="x"> </span><span class="k">interface</span><span class="x"> </span><span class="p">{</span><span class="x">
  </span><span class="n">Render</span><span class="p">(</span><span class="n">i</span><span class="x"> </span><span class="k">interface</span><span class="p">{})</span><span class="x">
</span><span class="p">}</span></code></pre>

<p>There is a helper function in the <code>github.com/dynport/urknall/utils</code> packages
named <code>MustRenderTemplate</code> that can be used to do the actual rendering.</p>

<h3 id="the-validator-interface">The <code>Validator</code> Interface</h3>

<p>The <code>Validator</code> interface can be used to do more complex validations, like
making sure all required values are set properly.</p>

<pre><code class="language-golang highlight"><span class="k">type</span><span class="x"> </span><span class="n">Validator</span><span class="x"> </span><span class="k">interface</span><span class="x"> </span><span class="p">{</span><span class="x">
  </span><span class="n">Validate</span><span class="p">()</span><span class="x"> </span><span class="kt">error</span><span class="x">
</span><span class="p">}</span></code></pre>

<p>TODO: well that could be described better I guess</p>

<h2 id="tasks">Tasks</h2>

<p>Tasks are ordered collections of commands. Usually there is no need to handle
them manually, except for situation’s where conditionals are required inside a
cached entity. The following subsection will describe this scenario. In the
following caching will be described as tasks are the layer where it is applied.</p>

<h3 id="manual-task-generation">Manual Task Generation</h3>

<p>Urknall provides the <code>NewTask</code> function that will generate a blank task that
commands can be added to manually.</p>

<p>TODO: missing example that properly explains the need for this. cache breaking for bundle install?</p>

<h3 id="caching">Caching</h3>

<p>One of the core features of urknall is the caching layer that will decide
whether or not a command must be executed. This is essential if provisioning is
run more than once, which is useful in many situations:</p>

<ul>
  <li>While developing templates the turnaround time is pretty short, as only
changed or added parts need to be executed.</li>
  <li>When an already provisioned target must be extended only the relevant parts
are touched.</li>
  <li>Changes to an existing setup are possible without disrupting the overall
service.</li>
</ul>

<p>Without this feature repeated provisioning would only be possible if all
commands would be idempotent, i.e. could be run over and over again without
changing results. This is a stark restriction that would require a lot of
thought to get right.</p>

<p>TODO: Is it even possible to build proper idempotent commands without being
      restricted to trivial problems?</p>

<p>Each task is defined by the ordered list of commands that need to be executed.
The commands are identified by the hash of the command actually executed. If it
was executed successfully a file will be written on the target. These files can
be found under <code>/var/lib/urknall/&lt;task-name&gt;/&lt;hash&gt;.done</code>. Prior to running a
task all files with this pattern from this directory will be listed.  This list
can be used as foundation for the cache. If a command’s hash is contained in
this list the command must not be executed again. If it isn’t all remaining
commands must be executed.</p>

<p>TODO: add information on how to best partition the cache.</p>

<h2 id="packages">Packages</h2>

<p>Packages are an strictly internal data-structure. It is a container for all the
tasks that must be executed on the target. The interface is just exposed to the
user when rendering templates. There are three possibilities for adding tasks:</p>

<ul>
  <li>Using the <code>AddTemplate</code> method the given template will be rendered into the
current template, i.e. all tasks generated inside the “child” template are
added to the “parent”. This is required to build template hierarchies.</li>
  <li>The <code>AddTask</code> method will add the given manually created task.</li>
  <li>With <code>AddCommands</code> a task is generated internally using the list of commands
given.</li>
</ul>

<p>Each of these commands is given a string that is used as identifier for the
underlying task. In case of template hierarchies the different layers’ names
are concatenated using dots.</p>

<h2 id="templates">Templates</h2>

<p>Templates are used to define the list of tasks that should be performed during
provisioning. Conceptually they are structs that implement the <code>Template</code>
interface, i.e. have a <code>Render</code> method that will extend a given <code>Package</code>. For
convenience there is a <code>TemplateFunc</code> type that allows to add templates without
configuration, i.e. a simple Render function.</p>

<p>When building a template hierarchy, from the root template given to the <code>Build</code>
function towards some more generic templates it might be necessary to have a
lot of configuration options on the root, that are handed through to the leafs.
This way there is a single interface for setting and changing configuration
which helps with handling more complex scenarios.</p>

<p>When creating the <code>main.go</code> file using the <a href="../binary/#init">urknall binary</a> a
simple template without configuration is generated.</p>

<pre><code class="language-golang highlight"><span class="k">type</span><span class="x"> </span><span class="n">Template</span><span class="x"> </span><span class="k">struct</span><span class="x"> </span><span class="p">{</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">tpl</span><span class="x"> </span><span class="o">*</span><span class="n">Template</span><span class="p">)</span><span class="x"> </span><span class="n">Render</span><span class="p">(</span><span class="n">p</span><span class="x"> </span><span class="n">urknall</span><span class="o">.</span><span class="n">Package</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
  </span><span class="n">p</span><span class="o">.</span><span class="n">AddCommands</span><span class="p">(</span><span class="s">"hello"</span><span class="p">,</span><span class="x"> </span><span class="n">Shell</span><span class="p">(</span><span class="s">"echo hello world"</span><span class="p">))</span><span class="x">
</span><span class="p">}</span></code></pre>

<p>As the template has no configuration the example could be changed to use the
<code>TemplateFunc</code> mechanism as described in the next subsection. The last
subsection describes the annotation mechanism provided by urknall to give
constraints on a template’s configuration.</p>

<h3 id="anonymous-render-function">Anonymous Render Function</h3>

<p>Sometimes there are templates that don’t have any configuration. There is the
<code>TemplateFunc</code> mechanism shown in the following example to avoid unnecessary code.</p>

<pre><code class="language-golang highlight"><span class="k">func</span><span class="x"> </span><span class="n">templateFunc</span><span class="p">(</span><span class="n">pkg</span><span class="x"> </span><span class="n">urknall</span><span class="o">.</span><span class="n">Package</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
  </span><span class="n">pkg</span><span class="o">.</span><span class="n">AddCommands</span><span class="p">(</span><span class="s">"hello"</span><span class="p">,</span><span class="x"> </span><span class="n">Shell</span><span class="p">(</span><span class="s">"echo hello world"</span><span class="p">))</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">run</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
  </span><span class="k">return</span><span class="x"> </span><span class="n">urknall</span><span class="o">.</span><span class="n">Run</span><span class="p">(</span><span class="n">target</span><span class="p">,</span><span class="x"> </span><span class="n">urknall</span><span class="o">.</span><span class="n">TemplateFunc</span><span class="p">(</span><span class="n">templateFunc</span><span class="p">))</span><span class="x">
</span><span class="p">}</span></code></pre>

<h3 id="annotations">Annotations</h3>

<p>Urknall provides an annotation based mechanism to give further constraints on a
template’s configuration. In the <a href="../quickstart/">quickstart guide</a> the
<code>required</code> and <code>default</code> tags were used.</p>

<pre><code class="language-golang highlight"><span class="k">type</span><span class="x"> </span><span class="n">Template</span><span class="x"> </span><span class="k">struct</span><span class="x"> </span><span class="p">{</span><span class="x">
  </span><span class="n">RubyVersion</span><span class="x">  </span><span class="kt">string</span><span class="x"> </span><span class="s">`urknall:"required=true"`</span><span class="x">
  </span><span class="n">NginxVersion</span><span class="x"> </span><span class="kt">string</span><span class="x"> </span><span class="s">`urknall:"default=1.4.1"`</span><span class="x">
</span><span class="p">}</span></code></pre>

<p>Prior to rendering templates to a target, urknall will validate it. This
validation takes the annotations into account, i.e. it verifies that:</p>

<ul>
  <li>
<code>required</code> fields have not go’s zero value set.</li>
  <li>fields with a <code>default</code> tag get this value set if none was specified.</li>
  <li>an integer field with <code>min</code> or <code>max</code> annotations fullfill the respective
constraints.</li>
  <li>for string fields the value’s length is validate if the <code>size</code> annotation is
given.</li>
</ul>

<p>This helps to prevent missing configuration items prior to executing commands,
that would fail otherwise.</p>

<h2 id="targets">Targets</h2>

<p>The target is the “host” where the commands are executed on. Currently there is
support for remote execution using SSH and running commands locally.</p>

<h3 id="remot-target">Remot Target</h3>

<p>The remote target mechanism uses SSH to connect to the remote machine and sends
everything back and forth through this secured channel. The connection opened
initially is kept for the complete session.</p>

<p>Authentication on the remote host is either done using a password or
public key for the used user. The password based approach shouldn’t be used for
production setups so, but might be the most pragmatic solution for testing
purposes.</p>

<p>The public key authentication mechanism doesn’t search the <code>~/.ssh</code> directory
for keys, but relies on a configure <em>ssh-agent</em> running.</p>

<p>The <code>main.go</code> file created by the <a href="../binary/#init">urknall binary</a> provides
both mechanisms depending on the availability of a password, using the
<code>NewSshTarget</code> and <code>NewSshTargetWithPassword</code> respectively. The <code>uri</code> and
<code>password</code> must be configured depending of the user’s use case, of course.</p>

<pre><code class="language-golang highlight"><span class="k">func</span><span class="x"> </span><span class="n">run</span><span class="p">()</span><span class="x"> </span><span class="kt">error</span><span class="x"> </span><span class="p">{</span><span class="x">
  </span><span class="c">// [...]</span><span class="x">
  </span><span class="k">var</span><span class="x"> </span><span class="n">target</span><span class="x"> </span><span class="n">urknall</span><span class="o">.</span><span class="n">Target</span><span class="x">
  </span><span class="n">uri</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="s">"ubuntu@my.host"</span><span class="x">
  </span><span class="n">password</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="s">""</span><span class="x">
  </span><span class="k">if</span><span class="x"> </span><span class="n">password</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="s">""</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">target</span><span class="p">,</span><span class="x"> </span><span class="n">e</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">urknall</span><span class="o">.</span><span class="n">NewSshTargetWithPassword</span><span class="p">(</span><span class="n">uri</span><span class="p">,</span><span class="x"> </span><span class="n">password</span><span class="p">)</span><span class="x">
  </span><span class="p">}</span><span class="x"> </span><span class="k">else</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">target</span><span class="p">,</span><span class="x"> </span><span class="n">e</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">urknall</span><span class="o">.</span><span class="n">NewSshTarget</span><span class="p">(</span><span class="n">uri</span><span class="p">)</span><span class="x">
  </span><span class="p">}</span><span class="x">
  </span><span class="k">if</span><span class="x"> </span><span class="n">e</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="k">return</span><span class="x"> </span><span class="n">e</span><span class="x">
  </span><span class="p">}</span><span class="x">
 </span><span class="c">// [...]</span><span class="x">
</span><span class="p">}</span></code></pre>

<h3 id="local-target">Local Target</h3>

<p>This target can be used to provision the local host.</p>

<p>TODO: motivation?</p>

<h3 id="sudo-without-password">Sudo Without Password</h3>

<p>Urknall must be able to execute commands like installing packages or creating
users, which require <code>root</code> permissions. If you’re not provisioning
using the <code>root</code> user the <code>sudo</code> mechanism is required. As manual entry of
passwords is tedious it is required that the user is allowed sudo without
password. This can be achieved by adding the following setting (make sure you
change the username from ‘ubuntu’ to whatever suits you):</p>

<pre><code>echo "ubuntu ALL=(ALL) NOPASSWD:ALL" &gt; /etc/sudoers.d/90-nopassword
</code></pre>

<p>Now you should verify that there is no password required on running commands
with <code>sudo</code>.</p>


</div>


<hr/>

<footer>
<div class="container">
	<p>© <a href="http://www.dynport.de" target="_blank">Dynport GmbH</a> 2014</p>
</div>
</footer>


<!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="../../js/bootstrap.min.js"></script>
</body>
</html>
